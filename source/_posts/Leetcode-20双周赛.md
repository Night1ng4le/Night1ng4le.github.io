---
title: Leetcode - 20双周赛
categories: [Leetcode]
tags: [Double Week]
---

### 5323. 根据数字二进制下 1 的数目排序(Easy)

#### Problem Link
https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits/
#### Description
给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。

如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。

请你返回排序后的数组。

 <!--more-->

**示例 1：**
```
输入：arr = [0,1,2,3,4,5,6,7,8]
输出：[0,1,2,4,8,3,5,6,7]
解释：[0] 是唯一一个有 0 个 1 的数。
[1,2,4,8] 都有 1 个 1 。
[3,5,6] 有 2 个 1 。
[7] 有 3 个 1 。
按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]
```
**示例 2：**
```
输入：arr = [1024,512,256,128,64,32,16,8,4,2,1]
输出：[1,2,4,8,16,32,64,128,256,512,1024]
解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。
```
**示例 3：**
```
输入：arr = [10000,10000]
输出：[10000,10000]
```
**示例 4：**
```
输入：arr = [2,3,5,7,11,13,17,19]
输出：[2,3,5,17,7,11,13,19]
```
**示例 5：**
```
输入：arr = [10,100,1000,10000]
输出：[10,100,10000,1000]
```
 

**提示：**

1. 1 <= arr.length <= 500
2. 0 <= arr[i] <= 10^4

#### Solution
emmm看起来不是很难的一道题，核心问题是在自定义比较器。分解成两个子问题：
1. 统计数字二进制表示中1的个数
2. 按给定规则排序
```c++
//Version 1.0
class Solution {
public:
   vector<int> sortByBits(vector<int>& arr) {//排序方法我没有想到更好的，所以用了冒泡排序
    for (int i=0; i<arr.size(); i++) {
        for (int j=1; j<arr.size(); j++) {
            if(lessthan(arr[j-1], arr[j])==false){
                swap(arr[j-1], arr[j]);
            }
        }
    }
    return arr;
}
int count(int a){//统计数字二进制表达式中1的个数
    int num = 0;
    while (a) {
        num += (1&a);//判断最低位是不是1，第一次尝试位运算orz
        a>>=1;
    }
    return num;
}
    bool lessthan(int a, int b){//自定义比较器
        if (count(a)==count(b)) {
            return a<b;
        }
        return count(a)<count(b);
    }
    
};
```

### 碎碎念
写这个的时候快睡着了，题解是第二天写出来的，一开始自己写的时候没想到怎么定义比较器比较好（其实是因为懒得单独拎出来写成一个函数），后来发现功能模块越独立代码越清楚简单。所以下次没思路的时候可以考虑先写出会的功能模块，按子问题解决。
这里记录自己愚蠢而不细心的错误：
```c++
int count(int a){
        int num = 0;
        while (a) {
            if (num%2==1) {//这里判断条件应该是a%2==1
                num++;
            }
            a=a/2;
        }
        return num;
    }
```
以后会添加自己的错误模块，以便督促自己努力QAQ



