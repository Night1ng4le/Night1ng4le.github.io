---
title: OS - 页面置换算法
categories: [CS base]
tags: [OS]
---

OS页面置换算法简记，不系统



### 置换算法的概念
- 功能：选择被置换的物理页面
- 目标：尽可能减少调入调出次数
- `页面锁定`：某些页面不可被换出（OS相关、要求响应速度等）
	- 依靠页表中锁定标志位解决

<!-- more -->

#### 评价方法
- 模拟页面置换行为，记录缺页次数
- 缺页越少性能越好

#### 分类
- 局部置换算法
	- 置换页面选择范围仅限当前进程所占物理页面
- 全局置换算法
	- 选择范围：所有可换出物理页面


### 局部置换算法
进程所能使用的物理页面数目固定

#### 最优算法（OPT）
- 置换未来最长时间不访问的页面
- `无法实现`，由于无法预测
- 作为其他置换算法的性能评价标准

#### 先进先出（FIFO）
- 实现简单
- 性能差
- Belady现象
- 很少单独使用
- 数据结构：链表

#### 最近最久未使用（LRU）
- 最长时间没有被使用到的(统计时间)
- 近似OPT，开销大，难以实现
- 栈/链表实现，日常维护开销过大

#### 时钟置换算法（Clock）
- 仅记录页面是否被访问过，不记录访问次数
- 数据结构：
	- 访问位：访问置1，未访问置0
	- 环形链表
- 特征：LRU和FIFO的折中，页面等价的情况下按FIFO

##### 改进的Clock算法
- 添加修改位
- 只读修改访问位，写修改两个标志位

#### 最不常用算法（LFU）
- 关注访问次数（次数越多越好）
- 对统计次数做定期右移进行衰减，避免有早期内存页长期驻留内存
- 对内存访问并不算好用，访问硬盘时相对合适


> Clock算法和LFU都是对LRU的某种简化，相应的统计精度会下降
> 选择页面置换算法即近似程度和准确性中做折中


#### 局部置换算法的比较
- OPT性能最好，FIFO性能最差。
- 对于未被访问的页面，所有置换算法性能均和FIFO一样
- 对于已被访问的页面，性能LRU > Clock > FIFO


### Belady现象
随着分配给进程的物理页面增加，其缺页率并没有减少，反而不变或增加。
- FIFO存在belady
- LRU没有belady
- `所有类似于栈式结构访问的都是没有belady的现象`


### 全局置换算法
局部置换没有考虑进程访存差异
- 思路：给进程分配数目可变的物理页面
- CPU利用率和并发进程数之间相互制约
	- 由于并发进程的内存访问会降低访存的局部性特征，因此缺页率上升，CPU利用率下降

#### 工作集算法
工作集：进程某段时间使用的逻辑页面的集合
常驻集：当前时刻，进程实际驻留内存当中的页面集合
- 常驻集包括工作集时，缺页较少
- 工作集切换之间，缺页较多
- 进程的常驻集大小达到一定数目后，缺页率不会明显下降

工作集置换算法：
- 思路：置换出不在工作集中的页面
- 当前时刻前t个内存访问的页的引用是工作集，t为窗口大小
- 开销相对较大



#### 缺页率算法
```
缺页率 = 缺页次数/内存访问次数
or
缺页率 = 缺页平均时间间隔的倒数
```
缺页率影响因素：
- `页面置换算法`
- 进程所拥有的物理页面数目
- 页面大小
- 程序编写方法

缺页率置换算法
- 思路：通过调节常驻集大小，使每个进程的缺页率保持在一个合理的范围内
	- 缺页率过高，增加进程物理页面
	- 缺页率过低，减少进程物理页面
- 实现：确定一个常量T，如果缺页
	- 当前时刻 - 上次缺页时刻 > T，换出两次时间节点之间没有被引用的页
	- 当前时刻 - 上次缺页时刻 ≤ T，增加缺页到常驻集


### 抖动和负载控制

#### 抖动
抖动：
- 进程物理页面少，不能包含工作集
- 大量缺页，置换频繁
- 进程运行速度慢

原因：内存中进程太多了

#### 负载控制
平均缺页间隔时间(MTBF) = 缺页异常处理时间(PFST)












